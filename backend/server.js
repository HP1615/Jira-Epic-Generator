const express = require('express');
const axios = require('axios');
const cors = require('cors');
require('dotenv').config();
const { OpenAI } = require('openai');
//const { fetchGitHubFiles } = require('./gitfileembedding');
const { fetchGitHubFiles, searchSimilarFiles, PANELNAME_TO_REPO} = require('./gitfileembedding');

const app = express();
app.use(cors());
app.use(express.json());

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Helper function to safely get field values
const getFieldValue = (fields, fieldId) => {
  try {
    const field = fields[fieldId];
    if (!field) return '';
    if (typeof field === 'object' && field.value) return field.value;
    if (typeof field === 'string') return field;
    return '';
  } catch (error) {
    return '';
  }
};

// Helper function to extract text from Atlassian Document Format
const extractTextFromADF = (adfContent) => {
  if (!adfContent || !adfContent.content) return '';
  return adfContent.content.reduce((text, item) => {
    if (item.type === 'paragraph' && item.content) {
      const paragraphText = item.content.reduce((paraText, contentItem) => {
        if (contentItem.type === 'text') {
          return paraText + contentItem.text;
        }
        return paraText;
      }, '');
      return text + paragraphText + '\n';
    }
    return text;
  }, '').trim();
};

// Helper function to create Atlassian Document Format
const createADF = (text) => {
  return {
    version: 1,
    type: "doc",
    content: [
      {
        type: "paragraph",
        content: [{ type: "text", text: text || '' }]
      }
    ]
  };
};

// Helper function to parse epic content into sections
const parseEpicContent = (content) => {
  const sections = {
    summary: '',
    description: '',
    iWant: '',
    soThat: '',
    acceptanceCriteria: ''
  };
  const lines = content.split('\n');
  let currentSection = '';
  for (const line of lines) {
    const trimmed = line.trim();
    if (/^(Epic Summary:|Summary:)/i.test(trimmed)) {
      currentSection = 'summary';
      const summaryValue = trimmed.replace(/^(Epic Summary:|Summary:)/i, '').trim();
      if (summaryValue) {
        sections.summary = summaryValue;
      }
    } else if (/^Description:/i.test(trimmed) || /^Business Context:/i.test(trimmed)) {
      currentSection = 'description';
    } else if (/^I Want:/i.test(trimmed)) {
      currentSection = 'iWant';
    } else if (/^So That:/i.test(trimmed)) {
      currentSection = 'soThat';
    } else if (/^Acceptance Criteria:/i.test(trimmed)) {
      currentSection = 'acceptanceCriteria';
    } else if (trimmed && currentSection) {
      if (currentSection !== 'summary') {
        sections[currentSection] += trimmed + '\n';
      } else if (!sections.summary && !/^(epic summary:|summary:)$/i.test(trimmed)) {
        sections.summary = trimmed;
      }
    }
  }
  if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
    const firstContentLine = lines.find(l =>
      l.trim() &&
      !/^epic summary:/i.test(l.trim()) &&
      !/^summary:/i.test(l.trim()) &&
      !/^description:/i.test(l.trim()) &&
      !/^business context:/i.test(l.trim()) &&
      !/^i want:/i.test(l.trim()) &&
      !/^so that:/i.test(l.trim()) &&
      !/^acceptance criteria:/i.test(l.trim())
    );
    sections.summary = firstContentLine ? firstContentLine.trim() : 'Epic generated by AI';
  }
  Object.keys(sections).forEach(key => {
    if (key !== 'summary') {
      sections[key] = sections[key].trim();
    }
  });
  //sections.summary = sections.summary.replace(/^(Epic Summary:|Summary:)/i, '').trim();
  sections.summary = sections.summary.replace(/^(Epic Summary:|Summary:)/i).trim();
  if (sections.summary.length > 150) {
    sections.summary = sections.summary.slice(0, 150);
  }
  if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
    sections.summary = 'Epic generated by AI';
  }
  return sections;
};

// Helper function to create Jira Epic
const createJiraEpic = async (epicContent, ticketIds) => {
  //const createJiraEpic = async (epicContent, ticketIds, keywords = []) => {
  try {
    if (!process.env.JIRA_PROJECT_KEY) {
      throw new Error('JIRA_PROJECT_KEY is not configured');
    }
    await axios.get(
      `${process.env.JIRA_BASE_URL}/rest/api/3/project/${process.env.JIRA_PROJECT_KEY}`,
      {
        auth: {
          username: process.env.JIRA_EMAIL,
          password: process.env.JIRA_API_TOKEN
        }
      }
    );
    const parsedContent = parseEpicContent(epicContent);
  
    console.log('Parsed Epic Content:', parsedContent);
    const response = await axios.post(
      `${process.env.JIRA_BASE_URL}/rest/api/3/issue`,
      {
        fields: {
          project: { key: process.env.JIRA_PROJECT_KEY },
          summary: parsedContent.summary,
          description: createADF(parsedContent.description),
          issuetype: { name: "Epic" },
          [process.env.JIRA_IWANT_FIELD]: createADF(parsedContent.iWant),
          [process.env.JIRA_SOTHAT_FIELD]: createADF(parsedContent.soThat),
          [process.env.JIRA_AC_FIELD]: createADF(parsedContent.acceptanceCriteria),
          assignee: { accountId: process.env.JIRA_TEAM_BA_ACCOUNT_ID },
          //customfield_10297: keywords.join(', ')
        }
      },
      {
        auth: {
          username: process.env.JIRA_EMAIL,
          password: process.env.JIRA_API_TOKEN
        },
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      }
    );
    console.log('=== JIRA EPIC CREATION DETAILS ===');
    console.log('Epic Key:', response.data.key);
    console.log('Epic URL:', `${process.env.JIRA_BASE_URL}/browse/${response.data.key}`);
    console.log('Linked Tickets:', ticketIds);
    console.log('================================');
    return response.data;
  } catch (error) {
    console.error('Error creating Jira Epic:',
      error.response?.data?.errors ||
      error.response?.data?.errorMessages ||
      error.message
    );
    throw error;
  }
};

// AGENT 1: Ticket Reader Agent (fetches a single enhancement ticket by key)
const fetchEnhancementTicketByKey = async (ticketKey) => {
  try {
    const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
    let response;
    try {
      response = await axios.get(
        `${process.env.JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}`,
        {
          auth: {
            username: process.env.JIRA_EMAIL,
            password: process.env.JIRA_API_TOKEN
          },
          headers: { Accept: 'application/json' }
        }
      );
    } catch (error) {
      console.error("Jira errorMessages:", error.response?.data?.errorMessages);
      return null;
    }
    const issue = response.data;
    if (!issue.fields.hasOwnProperty(docByField)) {
      console.error(`Field '${docByField}' is NOT present in the available fields. Check field context, screens, and permissions in Jira.`);
      return null;
    }
    if (
      issue.fields.issuetype?.name === "Enhancement" &&
      (Array.isArray(issue.fields[docByField])
        ? issue.fields[docByField][0]?.value
        : (issue.fields[docByField]?.value || issue.fields[docByField])) === "Automation"
    ) {
      return issue;
    }
    return null;
  } catch (error) {
    console.error("Error fetching enhancement ticket:", error.message);
    if (error.response?.data?.errorMessages) {
      console.error("Jira errorMessages:", error.response.data.errorMessages);
    }
    return null;
  }
};

// AGENT 2: Context Extractor Agent (extracts panelName and formPath)
async function extractFunctionalKeywordsFromTicket(ticket) {
  const prompt = `
Given the following Jira enhancement ticket details, extract 3-8 keywords or short phrases that best describe the main functionality, features, or business logic of the ticket. 
Ignore generic words like "the", "this", "that", "need", "user", "system", etc. 
Focus on terms that would help find other tickets with similar functionality. 
Return the keywords as a comma-separated list.

Summary: ${ticket.summary}
Description: ${ticket.description}
I Want: ${ticket.iWant}
So That: ${ticket.soThat}
Acceptance Criteria: ${ticket.acceptanceCriteria}
`;

  const completion = await openai.chat.completions.create({
    model: "gpt-4.1-nano",
    messages: [
      { role: "system", content: "You are an expert at extracting concise, relevant keywords from Jira tickets." },
      { role: "user", content: prompt }
    ],
    temperature: 0.2,
    max_tokens: 100
  });

  const keywordsRaw = completion.choices[0].message.content || '';
  return keywordsRaw
    .split(',')
    .map(k => k.trim())
    .filter(k => k.length > 1);
}

const extractTicketContext = async (issue) => {
  const fields = issue.fields || {};
  const iWantField = process.env.JIRA_IWANT_FIELD;
  const soThatField = process.env.JIRA_SOTHAT_FIELD;
  const acField = process.env.JIRA_AC_FIELD;

  // // Extract panel name (adjust field name if needed)
  // const panelName =
  //   fields.panelName ||
  //   fields["Panel Name"] ||
  //   fields["customfield_PANELNAME"] ||
  //   fields["customfield_10082"] || 
  //   "";

  function extractPanelName(fields) {
  const candidates = [
    fields.panelName,
    fields["Panel Name"],
    fields["customfield_PANELNAME"],
    fields["customfield_10082"]
  ];
  for (const candidate of candidates) {
    if (typeof candidate === "string" && candidate.trim()) return candidate.trim();
    if (candidate && typeof candidate === "object" && candidate.value) return candidate.value;
  }
  return "";
}

// In your extractTicketContext:
const panelName = extractPanelName(fields);

  // Extract form path from customfield_10297 (ADF or string)
  // let formPath = "";
  // if (fields.customfield_10297 && typeof fields.customfield_10297 === "object" && fields.customfield_10297.content) {
  //   formPath = extractTextFromADF(fields.customfield_10297);
  // } else if (typeof fields.customfield_10297 === "string") {
  //   formPath = fields.customfield_10297;
  // }

  // Extract form path from customfield_10297 (ADF or string)
let formPath = [];
if (fields.customfield_10297 && typeof fields.customfield_10297 === "object" && fields.customfield_10297.content) {
  formPath = extractTextFromADF(fields.customfield_10297)
    .split(',')
    .map(f => f.trim())
    .filter(f => f.length > 0);
} else if (typeof fields.customfield_10297 === "string") {
  formPath = fields.customfield_10297
    .split(',')
    .map(f => f.trim())
    .filter(f => f.length > 0);
}

  function extractADFValue(val) {
    if (!val) return '';
    if (typeof val === 'string') return val;
    if (typeof val === 'object' && val.type === 'doc' && Array.isArray(val.content)) {
      function extractFromNodes(nodes) {
        let result = '';
        for (const node of nodes) {
          if (node.type === 'paragraph' && Array.isArray(node.content)) {
            for (const item of node.content) {
              if (item.type === 'text') result += item.text;
            }
            result += '\n';
          } else if ((node.type === 'orderedList' || node.type === 'bulletList') && Array.isArray(node.content)) {
            for (const listItem of node.content) {
              if (Array.isArray(listItem.content)) {
                result += '- ';
                result += extractFromNodes(listItem.content).replace(/\n$/, '') + '\n';
              }
            }
          } else if (node.type === 'listItem' && Array.isArray(node.content)) {
            result += extractFromNodes(node.content);
          }
        }
        return result;
      }
      return extractFromNodes(val.content).trim();
    }
    return '';
  }

  let iWant = '';
  let soThat = '';
  let acceptanceCriteria = '';

  if (iWantField && fields[iWantField] !== undefined) {
    iWant = extractADFValue(fields[iWantField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('iwant'));
    if (foundKey) {
      iWant = extractADFValue(fields[foundKey]);
    }
  }

  if (soThatField && fields[soThatField] !== undefined) {
    soThat = extractADFValue(fields[soThatField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('sothat'));
    if (foundKey) {
      soThat = extractADFValue(fields[foundKey]);
    }
  }

  if (acField && fields[acField] !== undefined) {
    acceptanceCriteria = extractADFValue(fields[acField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('acceptance'));
    if (foundKey) {
      acceptanceCriteria = extractADFValue(fields[foundKey]);
    }
  }

  const keywords = await extractFunctionalKeywordsFromTicket({
    summary: fields.summary || "",
    description: typeof fields.description === 'object'
      ? extractTextFromADF(fields.description)
      : (fields.description || ""),
    iWant,
    soThat,
    acceptanceCriteria
  });

  //console.log('Extracted Keywords:', keywords);

  // If formPath is empty, use keywords as formPath
if (!formPath || (Array.isArray(formPath) && formPath.length === 0)) {
  formPath = keywords;
}

  return {
    id: issue.key,
    summary: fields.summary || "",
    description: typeof fields.description === 'object'
      ? extractTextFromADF(fields.description)
      : (fields.description || ""),
    iWant,
    soThat,
    acceptanceCriteria,
    keywords,
    panelName,
    formPath
  };
};

// AGENT 3: Similar Ticket Retriever Agent (batching, uses keywords)
const fetchSimilarTicketsBatch = async (targetTicket, batchSize = 50) => {
  console.log("Starting to fetch similar tickets for:", targetTicket.id);
  const keywordsArr = targetTicket.keywords || [];
  if (keywordsArr.length === 0) {
    console.warn('No suitable keywords for JQL. Skipping similar ticket search.');
    return [];
  }
  // const keywordString = keywordsArr.join(' OR ');
  // const jql = `type = Enhancement AND status = Released AND project = RSOFT AND key != "${targetTicket.id}" AND textfields ~ "${keywordString}"`;
  const keywordClauses = keywordsArr
  .map(k => `textfields ~ "${k.replace(/"/g, '\\"')}"`)
  .join(' OR ');
const jql = `type = Enhancement AND status = Released AND project = RSOFT AND key != "${targetTicket.id}" AND (${keywordClauses})`;
//const jql = `type IN (Test, "Enhancement Defect", Enhancement) AND status = Released AND project = RSOFT AND key != "${targetTicket.id}" AND (${keywordClauses})`;  
console.log(`JQL for similar tickets: ${jql}`);

  let startAt = 0;
  let allSimilar = [];
  while (true) {
    try {
      const response = await axios.get(
        `${process.env.JIRA_BASE_URL}/rest/api/3/search`,
        {
          params: {
            jql,
            fields: [
              "summary",
              "description",
              process.env.JIRA_IWANT_FIELD,
              process.env.JIRA_SOTHAT_FIELD,
              process.env.JIRA_AC_FIELD,
              process.env.JIRA_DOCBY_FIELD,
              "issuetype",
              "status"
            ].join(","),
            maxResults: batchSize,
            startAt
          },
          auth: {
            username: process.env.JIRA_EMAIL,
            password: process.env.JIRA_API_TOKEN
          },
          headers: { Accept: 'application/json' }
        }
      );
      const issues = response.data.issues || [];
      console.log(`Fetched ${issues.length} similar tickets (batch starting at ${startAt})`);
      allSimilar.push(...issues);
      if (issues.length < batchSize) break;
      startAt += batchSize;
    } catch (error) {
      console.error("Error fetching similar tickets batch:", error.response?.data?.errorMessages || error.message);
      console.error("JQL used:", jql);
      break;
    }
  }
  const targetWords = new Set(keywordsArr.map(w => w.toLowerCase()));
  const filtered = await Promise.all(
    allSimilar.map(async issue => {
      const t = await extractTicketContext(issue);
      const words = new Set((t.keywords || []).map(w => w.toLowerCase()));
      const intersection = [...words].filter(w => targetWords.has(w));
      return intersection.length > 0 ? t : null;
    })
  );
  const filteredTickets = filtered.filter(Boolean);
  console.log(`Filtered to ${filteredTickets.length} truly similar tickets:`, filteredTickets.map(t => t.id).join(', '));
 
  if (filteredTickets.length > 0) {
  const refinedJQL = `key in (${filteredTickets.map(t => t.id).join(', ')})`;
  console.log("JQL for refined similar tickets:", refinedJQL);
}
  return filteredTickets;
};

// AGENT 4: Ticket Code Context Retriever (panelName + formPath, supports embeddings and OpenAI for plain English)
// async function fetchTicketCodeContext(panelName, formPath, branch = 'develop') {
//   console.log(`Fetching code context for panel: ${panelName}, formPath: ${formPath}, branch: ${branch}`);
//   // Make panel name lookup case-insensitive for robustness
//   let repoName = PANELNAME_TO_REPO[panelName];
//   if (!repoName) {
//     // Try case-insensitive match
//     const key = Object.keys(PANELNAME_TO_REPO).find(
//       k => k.toLowerCase() === String(panelName).toLowerCase()
//     );
//     repoName = PANELNAME_TO_REPO[key];
//   }
//   if (!repoName) {
//     throw new Error(`Unknown panel name: ${panelName}`);
//   }
 
// const CODE_FILE_REGEX = /\.(js|ts|jsx|tsx|py|java|php|cs|cpp|c|go|rb|swift|kt|rs|scala|sh|pl|json|xml|yml|yaml|md|aspx|aspx\.cs)$/i;
// const EXCLUDE_FILE_REGEX = /\.(css|scss|sass|less|html?|png|jpe?g|gif|svg|bmp|webp|ico|mp3|wav|ogg|mp4|mov|avi|pdf|docx?|xlsx?|pptx?)$/i;
 
// let fileNames = [];
 

//  //console.log("type of formpath ", typeof formPath);
 
// //   if (Array.isArray(formPath)) {
// //   // If all entries look like file names, use them directly
// //   const allLookLikeFiles = formPath.every(f => CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f));
// //   if (allLookLikeFiles) {
// //     fileNames = formPath;
// //   } 
// //   else
// //    if (typeof searchSimilarFiles === "function") {
// //     // PRIORITY LOGIC: Try first keyword, then second, etc., until you have enough files
// //     const collectionName = `${repoName}_files`;
// //     let foundFiles = [];
// //     let usedFiles = new Set();
// //     for (const keyword of formPath) {
// //       if (foundFiles.length >= 5) break; // Stop if you have enough files
// //       const similar = await searchSimilarFiles(keyword, collectionName, 100);
// //       for (const file of similar) {
// //         if (!usedFiles.has(file) && foundFiles.length < 5) {
// //           foundFiles.push(file);
// //           usedFiles.add(file);
// //         }
// //         if (foundFiles.length >= 5) break;
// //   }
// //   if (foundFiles.length >= 5) break;
// //     }
// //     fileNames = foundFiles.filter(f => CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f));
// //   }
 
// // }  
// if (Array.isArray(formPath)) {
//   // If all entries look like file names, use them directly
//   const allLookLikeFiles = formPath.every(f => CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f));
//   if (allLookLikeFiles) {
//     fileNames = formPath;
//   } 
//   else if (typeof searchSimilarFiles === "function") {
//   const collectionName = `${repoName}_files`;
//   let foundFiles = [];
//   let usedFiles = new Set();
//   for (const keyword of formPath) {
//     const similar = await searchSimilarFiles(keyword, collectionName, 100);
//     for (const file of similar) {
//       if (!usedFiles.has(file) && foundFiles.length < 5) {
//         foundFiles.push(file);
//         usedFiles.add(file);
//       }
//       if (foundFiles.length >= 5) break; // Only break inner loop
//     }
//     // Do NOT break here; let it try all keywords
//   }
//   fileNames = foundFiles.filter(f => CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f));
// }
// }
// //  if (Array.isArray(formPath)) {
// //     fileNames = formPath;
// //   } 
//   else
// if (typeof formPath === "string") {

//   // If it looks like file(s), use directly; otherwise, use embeddings to search
//   const isLikelyFileList = formPath.match(/\.(js|ts|jsx|tsx|py|java|php|cs|cpp|c|go|rb|swift|kt|rs|scala|sh|pl|json|xml|yml|yaml|md|aspx|aspx\.cs)(\s*,\s*|\s*$)/i);
//  console.log("isLikelyFileList",isLikelyFileList);
 
//   if (isLikelyFileList) {
//     fileNames = formPath.split(",").map(f => f.trim()).filter(f =>
//       CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f)
//     );
//   } else if (typeof searchSimilarFiles === "function") {
//     console.log("formPath", formPath);
   
//     const collectionName = `${repoName}_files`;
//     fileNames = (await searchSimilarFiles(formPath, collectionName, 10))
//       .filter(f => CODE_FILE_REGEX.test(f) && !EXCLUDE_FILE_REGEX.test(f))
//       .slice(0, 5);
//   } else {
//     if (CODE_FILE_REGEX.test(formPath) && !EXCLUDE_FILE_REGEX.test(formPath)) {
//       fileNames = [formPath];
//     }
//   }
// }
//   if (!fileNames.length) {
//     throw new Error("No valid file names found in formPath or via embeddings.");
//   }

async function fetchTicketCodeContext(panelName, formPath, branch = 'develop', ticketContext = {}) {
  console.log(`Fetching code context for panel: ${panelName}, formPath: ${formPath}, branch: ${branch}`);

  let repoName = PANELNAME_TO_REPO[panelName];
  if (!repoName) {
    const key = Object.keys(PANELNAME_TO_REPO).find(
      k => k.toLowerCase() === String(panelName).toLowerCase()
    );
    repoName = PANELNAME_TO_REPO[key];
  }
  if (!repoName) {
    throw new Error(`Unknown panel name: ${panelName}`);
  }

  const CODE_FILE_REGEX = /\.(js|ts|jsx|tsx|py|java|php|cs|cpp|c|go|rb|swift|kt|rs|scala|sh|pl|json|xml|yml|yaml|md|aspx|aspx\.cs)$/i;
  const EXCLUDE_FILE_REGEX = /\.(css|scss|sass|less|html?|png|jpe?g|gif|svg|bmp|webp|ico|mp3|wav|ogg|mp4|mov|avi|pdf|docx?|xlsx?|pptx?)$/i;

  let fileNames = [];

  // --- Gather all context keywords ---
  let contextKeywords = [];
  if (ticketContext) {
    if (ticketContext.summary) contextKeywords.push(ticketContext.summary);
    if (ticketContext.description) contextKeywords.push(ticketContext.description);
    if (Array.isArray(ticketContext.keywords)) contextKeywords.push(...ticketContext.keywords);
    if (Array.isArray(ticketContext.similarTickets)) {
      ticketContext.similarTickets.forEach(t => {
        if (Array.isArray(t.keywords)) contextKeywords.push(...t.keywords);
      });
    }
  }
  // Add formPath keywords
  if (Array.isArray(formPath)) {
    contextKeywords.push(...formPath);
  } else if (typeof formPath === "string") {
    contextKeywords.push(formPath);
  }
  // Remove duplicates and empty
  contextKeywords = [...new Set(contextKeywords.map(k => k && k.trim()).filter(Boolean))];

  // --- Semantic search for files/folders ---
  if (typeof searchSimilarFiles === "function") {
    const collectionName = `${repoName}_files`;
    let foundFiles = [];
    let usedFiles = new Set();
    for (const keyword of contextKeywords) {
      // This should use embeddings to find semantically similar files/folders
      const similar = await searchSimilarFiles(keyword, collectionName, 20); // Increase limit for more coverage
      for (const file of similar) {
        if (!usedFiles.has(file) && CODE_FILE_REGEX.test(file) && !EXCLUDE_FILE_REGEX.test(file)) {
          foundFiles.push(file);
          usedFiles.add(file);
        }
        if (foundFiles.length >= 5) break; // Limit total results
      }
      if (foundFiles.length >= 5) break;
    }
    fileNames = foundFiles;
  }

  if (!fileNames.length) {
    throw new Error("No valid file names found in context or via embeddings.");
  }

 
 console.log("fileNames",fileNames);
 
  // Fetch the code content for each file
  const codeFiles = await fetchGitHubFiles(fileNames, repoName, branch);
console.log("Fetched code files:", codeFiles);
 
  // Combine all file contents into a single string
  let allFilesContent = "";
  if (Array.isArray(codeFiles)) {
    allFilesContent = codeFiles.map(f => `### File: ${f.fileName}\n${f.content}`).join("\n\n");
  }
  else if (codeFiles.combinedContent) {
    allFilesContent = codeFiles.combinedContent;
  }
  //  else if (codeFiles.plainEnglishDescription) {
  //   // Already plain English, just use it
  //   return {
  //     repoName,
  //     fileNames,
  //     plainEnglishDescription: codeFiles.plainEnglishDescription
  //   };
   else {
    allFilesContent = String(codeFiles);
  }
 
  // Use OpenAI to convert code to plain English
  const prompt = `

  Analyze the following code and perform the following tasks:
1. Provide a concise plain English summary of the code’s main purpose and functionality.
2. List all input fields as they appear on the UI, including:
   - Field label/name
   - Data type (e.g., text, number, dropdown)
   - Required/optional status
   - Default values or constraints
3. Describe the UI flow step-by-step, including any conditional logic (e.g., fields that appear/disappear).
4. For each field, explain its action, validation, and how its value is used.
5. Summarize any validation rules, error messages, and edge cases.
 
Code:
${codeFiles.plainEnglishDescription}
`;
 
  const completion = await openai.chat.completions.create({
    model: "gpt-4.1-nano",
    messages: [
      { role: "system", content: "You are an expert software analyst who explains code in plain English and extracts UI/UX details." },
      { role: "user", content: prompt }
    ],
    temperature: 0.3,
    max_tokens: 800
  });
  //console.log("OpenAI completion response:", completion);
 
  const plainEnglishDescription = completion.choices[0].message.content;
  //console.log("Plain English description generated:", plainEnglishDescription);
 
  return {
    repoName,
    fileNames
    //plainEnglishDescription
  };
}

// AGENT 5: Epic Creator Agent (combines all agents)
// const createEpicWithAllContext = async ({
//   ticketKey,
//   panelName,
//   formPath,
//   dryRun = true
// }) => {
//   const rawTicket = await fetchEnhancementTicketByKey(ticketKey);
//   if (!rawTicket) throw new Error("No matching enhancement ticket found.");

//   const ticket = await extractTicketContext(rawTicket);
//   const similarTickets = await fetchSimilarTicketsBatch(ticket);

//   // Use panelName and formPath from the ticket if not provided
//   const codeContext = await fetchTicketCodeContext(
 
//     panelName || ticket.panelName,
//     formPath || ticket.formPath
//   );

//   console.log('Code context fetched:', codeContext);

//   const tickets = [ticket, ...similarTickets];
//   const similarTicketsMap = {};
//   tickets.forEach(t => {
//     similarTicketsMap[t.id] = tickets.filter(other => other.id !== t.id && (() => {
//       const tWords = new Set((t.keywords || []).map(w => w.toLowerCase()));
//       const oWords = new Set((other.keywords || []).map(w => w.toLowerCase()));
//       const intersection = [...tWords].filter(w => oWords.has(w));
//       return intersection.length > 0;
//     })());
//   });

//   const epicContent = await generateEpicFromTickets(tickets, similarTicketsMap, codeContext);

//   const parsedContent = parseEpicContent(epicContent);

//   if (dryRun) {
//     return {
//       dummyEpicKey: 'DUMMY-EPIC-KEY',
//       summary: parsedContent.summary,
//       description: parsedContent.description,
//       iWant: parsedContent.iWant,
//       soThat: parsedContent.soThat,
//       acceptanceCriteria: parsedContent.acceptanceCriteria,
//       codeContext,
//       fullEpicContent: epicContent
//     };
//   }

//   const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id));
//   return {
//     jiraEpicKey: jiraEpic?.key,
//     jiraEpicUrl: jiraEpic ? `${process.env.JIRA_BASE_URL}/browse/${jiraEpic.key}` : null
//   };
// };

// AGENT 5- Epic Generator(combines all agents)
const generateEpicFromTickets = async (tickets, similarTicketsMap, codeContext = null) => {
  const codeSection = codeContext
    ? `\n\nCode Context (from panel "${codeContext.repoName}", files: ${codeContext.fileNames.join(', ')}):\n${codeContext.plainEnglishDescription}\n`
    : '';
    console.log('Code context:', codeContext);
  const prompt = `
You are a Business Analyst. Based on the following Jira enhancement tickets and their similar tickets, write a comprehensive Jira Epic.

Tickets:
${tickets.map(t => `
Ticket [${t.id}]:
Summary: ${t.summary}
Description: ${t.description}
I Want: ${t.iWant}
So That: ${t.soThat}
Acceptance Criteria: ${t.acceptanceCriteria}
Similar Tickets: ${similarTicketsMap[t.id].map(st => st.id).join(', ')}
-------------------`).join('\n')}
${codeSection}
Please structure your response in the following format:

Summary: [Write a clear, specific, and outcome-focused summary]

Description:
[Provide a brief overview of the business need and value]

I Want:
[Outline the main features and capabilities to be delivered]
[Describe the key requirements, organized by theme]

Acceptance Criteria:
[List each acceptance criterion as a separate, numbered or bulleted item]
[Each criterion must be specific, measurable, and testable]
[Focus on what must be true for the requirement to be considered complete]
[Avoid vague language; use clear conditions and expected outcomes]

So That:
[The requirement benefits or outcomes expected from this Epic]

Guidelines:
// - Combine and consolidate similar requirements
// - Eliminate redundancies while maintaining complete scope
// - Ensure traceability to original tickets
// - Keep the description business-oriented and implementation-neutral

Guidelines for Epic Generation:

Understand the Enhancement Ticket First
-Begin by clearly stating what the original ticket is trying to achieve.
-Capture the purpose and user/business motivation behind it.
-Use its Summary, I Want, So That, and Acceptance Criteria fields.

Incorporate Relevant Learnings from Similar Tickets
-Identify overlapping or related functionalities from similar released tickets.
-Merge common requirements or patterns into generalized capabilities.
-If certain features were already implemented elsewhere, mention them and avoid repetition.
-Use similar tickets to expand, refine, or validate the Epic’s scope.

Leverage Code Context Thoughtfully

-Use code context to:
-Confirm what part of the functionality may already be implemented.
-Identify which UI panels/forms/APIs are involved.
-Extract actual field names, flows, or validation logic from the UI.
-Convert technical elements into plain business-friendly statements.
-If the code shows existing behavior, highlight gaps or needed changes in the Epic.

Structure for Traceability and Actionability

-Each section must help developers and business users understand the “why” and “what” clearly.
-Use clean, numbered/bulleted Acceptance Criteria that can be tested or validated.
-If reused logic or modules from similar tickets are inferred, document it in the description.

Be Clear About Scope

-If some functionality is already present based on code context or similar tickets, state what’s new vs. reused.
-Avoid duplicating effort — describe enhancements or extensions instead of re-building.

Be Business-Oriented First, Technical Only Where Needed
-Write for a BA and dev team audience.
-Minimize technical jargon unless it helps clarify the requirement.
-Use real examples from the similar tickets and code descriptions to clarify expectations.

Preserve Jira Terminology and Format
Use standard Jira Epic format:

-Summary
-Description
-I Want
-So That
-Acceptance Criteria

Ensure each section contains only what it’s meant to — e.g., no ACs in Description.
`;

  const completion = await openai.chat.completions.create({
    model: "gpt-4.1-nano",
    messages: [
      { role: "system", content: "You are a business analyst skilled at creating comprehensive epics from multiple user stories." },
      { role: "user", content: prompt }
    ],
    temperature: 0.7,
    max_tokens: 1200
  });

  console.log('Epic content generated by OpenAI');
  return completion.choices[0].message.content;
};

app.post('/jira-webhook', async (req, res) => {
  try {
    const webhookEvent = req.body;
    const dryRun = webhookEvent.dryRun === true;
    const issue = webhookEvent.issue;
    const changelog = webhookEvent.changelog;

    if (!issue || !changelog) {
      return res.status(200).json({ message: 'No issue/changelog in webhook, ignoring.' });
    }

    const issueType = issue.fields.issuetype?.name;
    const statusChange = changelog.items.find(
      item => item.field === 'status' && item.fromString === 'Open' && item.toString === 'Documentation'
    );

    const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
    const docByValue = Array.isArray(issue.fields[docByField])
      ? issue.fields[docByField][0]?.value
      : (issue.fields[docByField]?.value || issue.fields[docByField]);

    if (
      issueType !== 'Enhancement' ||
      !statusChange ||
      docByValue !== 'Automation'
    ) {
      return res.status(200).json({ message: 'Not Enhancement, not Open→Documentation, or Documentation By not Automation. Ignoring.' });
    }

    const ticketKey = issue.key;
    console.log("Received webhook for ticket:", ticketKey);
    const rawTicket = await fetchEnhancementTicketByKey(ticketKey);
    if (!rawTicket) {
      return res.status(404).json({ error: "No matching enhancement ticket found." });
    }
    console.log(`Fetched ticket: ${rawTicket.key} - ${rawTicket.fields.summary}`);
    const ticket = await extractTicketContext(rawTicket);
    console.log('Extracted ticket context:', ticket);

    const similarTickets = await fetchSimilarTicketsBatch(ticket);

    // --- AGENT 4: Fetch code context using panelName and formPath from the ticket ---
    let codeContext = null;
   try {
      if (ticket.panelName && ticket.formPath) {
        console.log("panelName", ticket.panelName);
        console.log("formPath", ticket.formPath);
        
        codeContext = await fetchTicketCodeContext(ticket.panelName, ticket.formPath);
      }
    } catch (err) {
      console.warn("Could not fetch code context for Epic:", err.message);
    }
    if (codeContext && codeContext.plainEnglishDescription) {
  //console.log('Plain English Description:', codeContext.plainEnglishDescription);
} else {
    //console.log('Plain English Description:', codeContext?.plainEnglishDescription);
}
    const tickets = [ticket, ...similarTickets];
    const similarTicketsMap = {};
    tickets.forEach(t => {
      similarTicketsMap[t.id] = tickets.filter(other => other.id !== t.id && (() => {
        const tWords = new Set((t.keywords || []).map(w => w.toLowerCase()));
        const oWords = new Set((other.keywords || []).map(w => w.toLowerCase()));
        const intersection = [...tWords].filter(w => oWords.has(w));
        return intersection.length > 0;
      })());
    });

    // Pass codeContext to the Epic Generator
    const epicContent = await generateEpicFromTickets(tickets, similarTicketsMap, codeContext);

    const parsedContent = parseEpicContent(epicContent);
    console.log('=== EPIC PREVIEW ===');
    console.log('Summary:', parsedContent.summary);
    console.log('Description:', parsedContent.description);
    console.log('I Want:', parsedContent.iWant);
    console.log('So That:', parsedContent.soThat);
    console.log('Acceptance Criteria:', parsedContent.acceptanceCriteria);
    if (codeContext) {
      console.log('Code Context:', codeContext);
    }
    console.log('====================');

    if (dryRun) {
      return res.json({
        dummyEpicKey: 'DUMMY-EPIC-KEY',
        summary: parsedContent.summary,
        description: parsedContent.description,
        iWant: parsedContent.iWant,
        soThat: parsedContent.soThat,
        acceptanceCriteria: parsedContent.acceptanceCriteria,
        codeContext,
        fullEpicContent: epicContent
      });
    }

    
    const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id));
    //const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id), ticket.keywords);
    res.json({
      jiraEpicKey: jiraEpic?.key,
      jiraEpicUrl: jiraEpic ? `${process.env.JIRA_BASE_URL}/browse/${jiraEpic.key}` : null
    });
  } catch (error) {
    console.error("Error in webhook epic generation:", error);
    const errorMessage = error.response?.data?.message || error.message;
    res.status(500).json({
      error: "Failed to auto-generate Epic from webhook",
      details: errorMessage
    });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'OK' });
});

// Error handler
app.use((err, req, res, next) => {
  console.error('Error:', err.message);
  res.status(500).json({ error: 'Internal server error' });
});

// Start the server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});