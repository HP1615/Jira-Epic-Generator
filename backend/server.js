// const express = require('express');
// const axios = require('axios');
// const cors = require('cors');
// require('dotenv').config();
// const { OpenAI } = require('openai');

// const app = express();
// app.use(cors());
// app.use(express.json());

// const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// // Helper function to safely get field values
// const getFieldValue = (fields, fieldId) => {
//   try {
//     const field = fields[fieldId];
//     if (!field) return '';
//     if (typeof field === 'object' && field.value) return field.value;
//     if (typeof field === 'string') return field;
//     return '';
//   } catch (error) {
//     return '';
//   }
// };

// // Helper function to extract text from Atlassian Document Format
// const extractTextFromADF = (adfContent) => {
//   if (!adfContent || !adfContent.content) return '';
//   return adfContent.content.reduce((text, item) => {
//     if (item.type === 'paragraph' && item.content) {
//       const paragraphText = item.content.reduce((paraText, contentItem) => {
//         if (contentItem.type === 'text') {
//           return paraText + contentItem.text;
//         }
//         return paraText;
//       }, '');
//       return text + paragraphText + '\n';
//     }
//     return text;
//   }, '').trim();
// };

// // Helper function to create Atlassian Document Format
// const createADF = (text) => {
//   return {
//     version: 1,
//     type: "doc",
//     content: [
//       {
//         type: "paragraph",
//         content: [{ type: "text", text: text || '' }]
//       }
//     ]
//   };
// };

// // Helper function to parse epic content into sections
// const parseEpicContent = (content) => {
//   const sections = {
//     summary: '',
//     description: '',
//     iWant: '',
//     soThat: '',
//     acceptanceCriteria: ''
//   };
//   const lines = content.split('\n');
//   let currentSection = '';
//   for (const line of lines) {
//     const trimmed = line.trim();
//     // Accept both "Epic Summary:" and "Summary:" as summary section
//     if (/^(Epic Summary:|Summary:)/i.test(trimmed)) {
//       currentSection = 'summary';
//       // Only set summary if there is actual content after the colon
//       const summaryValue = trimmed.replace(/^(Epic Summary:|Summary:)/i, '').trim();
//       if (summaryValue) {
//         sections.summary = summaryValue;
//       }
//       // If there is no summary value, do NOT set sections.summary to label
//     } else if (/^Description:/i.test(trimmed) || /^Business Context:/i.test(trimmed)) {
//       currentSection = 'description';
//     } else if (/^I Want:/i.test(trimmed)) {
//       currentSection = 'iWant';
//     } else if (/^So That:/i.test(trimmed)) {
//       currentSection = 'soThat';
//     } else if (/^Acceptance Criteria:/i.test(trimmed)) {
//       currentSection = 'acceptanceCriteria';
//     } else if (trimmed && currentSection) {
//       if (currentSection !== 'summary') {
//         sections[currentSection] += trimmed + '\n';
//       } else if (!sections.summary && !/^(epic summary:|summary:)$/i.test(trimmed)) {
//         // If summary section is active and not set, and line is not just a label, use this line as summary
//         sections.summary = trimmed;
//       }
//     }
//   }
//   // Fallback: If summary is still empty or just a label, use the first non-empty, non-header line
//   if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
//     const firstContentLine = lines.find(l =>
//       l.trim() &&
//       !/^epic summary:/i.test(l.trim()) &&
//       !/^summary:/i.test(l.trim()) &&
//       !/^description:/i.test(l.trim()) &&
//       !/^business context:/i.test(l.trim()) &&
//       !/^i want:/i.test(l.trim()) &&
//       !/^so that:/i.test(l.trim()) &&
//       !/^acceptance criteria:/i.test(l.trim())
//     );
//     sections.summary = firstContentLine ? firstContentLine.trim() : 'Epic generated by AI';
//   }
//   Object.keys(sections).forEach(key => {
//     if (key !== 'summary') {
//       sections[key] = sections[key].trim();
//     }
//   });
//   // Final clean-up: Remove any remaining summary label from summary and trim
//   sections.summary = sections.summary.replace(/^(Epic Summary:|Summary:)/i, '').trim();
//   // Enforce 255 character limit for summary
//   if (sections.summary.length > 255) {
//     sections.summary = sections.summary.slice(0, 252) + '...';
//   }
//   if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
//     sections.summary = 'Epic generated by AI';
//   }
//   return sections;
// };

// // Helper function to create Jira Epic
// const createJiraEpic = async (epicContent, ticketIds) => {
//   try {
//     if (!process.env.JIRA_PROJECT_KEY) {
//       throw new Error('JIRA_PROJECT_KEY is not configured');
//     }
//     // Validate project key exists
//     try {
//       await axios.get(
//         `${process.env.JIRA_BASE_URL}/rest/api/3/project/${process.env.JIRA_PROJECT_KEY}`,
//         {
//           auth: {
//             username: process.env.JIRA_EMAIL,
//             password: process.env.JIRA_API_TOKEN
//           }
//         }
//       );
//     } catch (error) {
//       throw new Error(`Invalid project key: ${process.env.JIRA_PROJECT_KEY}`);
//     }

//     const parsedContent = parseEpicContent(epicContent);
//     console.log('Parsed Epic Content:', parsedContent);
//     const response = await axios.post(
//       `${process.env.JIRA_BASE_URL}/rest/api/3/issue`,
//       {
//         fields: {
//           project: { key: process.env.JIRA_PROJECT_KEY },
//           summary: parsedContent.summary,
//           description: createADF(parsedContent.description),
//           issuetype: { name: "Epic" },
//           [process.env.JIRA_IWANT_FIELD]: createADF(parsedContent.iWant),
//           [process.env.JIRA_SOTHAT_FIELD]: createADF(parsedContent.soThat),
//           [process.env.JIRA_AC_FIELD]: createADF(parsedContent.acceptanceCriteria)
//         }
//       },
//       {
//         auth: {
//           username: process.env.JIRA_EMAIL,
//           password: process.env.JIRA_API_TOKEN
//         },
//         headers: {
//           'Accept': 'application/json',
//           'Content-Type': 'application/json'
//         }
//       }
//     );
//     console.log('=== JIRA EPIC CREATION DETAILS ===');
//     console.log('Epic Key:', response.data.key);
//     console.log('Epic URL:', `${process.env.JIRA_BASE_URL}/browse/${response.data.key}`);
//     console.log('Linked Tickets:', ticketIds);
//     console.log('================================');
//     return response.data;
//   } catch (error) {
//     console.error('Error creating Jira Epic:',
//       error.response?.data?.errors ||
//       error.response?.data?.errorMessages ||
//       error.message
//     );
//     throw error;
//   }
// };

// // AGENT 1: Ticket Reader Agent (fetches a single enhancement ticket by key)
// const fetchEnhancementTicketByKey = async (ticketKey) => {
//   try {
//     const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
//     let response;
//     try {
//       response = await axios.get(
//         `${process.env.JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}`,
//         {
//           auth: {
//             username: process.env.JIRA_EMAIL,
//             password: process.env.JIRA_API_TOKEN
//           },
//           headers: { Accept: 'application/json' }
//         }
//       );
//     } catch (error) {
//       // Log error and return
//       console.error("Jira errorMessages:", error.response?.data?.errorMessages);
//       return null;
//     }
//     const issue = response.data;
//     // Log all available fields for debugging
//     //console.log('Available fields:', Object.keys(issue.fields));
//     if (!issue.fields.hasOwnProperty(docByField)) {
//       console.error(`Field '${docByField}' is NOT present in the available fields. Check field context, screens, and permissions in Jira.`);
//       return null;
//     }
//     // Only return if it's an Enhancement and status is Documentation and DocBy = Automation
//     if (
//       issue.fields.issuetype?.name === "Enhancement" &&
//       (Array.isArray(issue.fields[docByField])
//         ? issue.fields[docByField][0]?.value
//         : (issue.fields[docByField]?.value || issue.fields[docByField])) === "Automation"
//     ) {
//       return issue;
//     }
//     return null;
//   } catch (error) {
//     console.error("Error fetching enhancement ticket:", error.message);
//     if (error.response?.data?.errorMessages) {
//       console.error("Jira errorMessages:", error.response.data.errorMessages);
//     }
//     return null;
//   }
// };

// // AGENT 2: Context Extractor Agent (async, uses OpenAI for keywords)
// async function extractFunctionalKeywordsFromTicket(ticket) {
//   const prompt = `
// Given the following Jira enhancement ticket details, extract 3-8 keywords or short phrases that best describe the main functionality, features, or business logic of the ticket. 
// Ignore generic words like "the", "this", "that", "need", "user", "system", etc. 
// Focus on terms that would help find other tickets with similar functionality. 
// Return the keywords as a comma-separated list.

// Summary: ${ticket.summary}
// Description: ${ticket.description}
// I Want: ${ticket.iWant}
// So That: ${ticket.soThat}
// Acceptance Criteria: ${ticket.acceptanceCriteria}
// `;

//   const completion = await openai.chat.completions.create({
//     model: "gpt-4.1-nano",
//     messages: [
//       { role: "system", content: "You are an expert at extracting concise, relevant keywords from Jira tickets." },
//       { role: "user", content: prompt }
//     ],
//     temperature: 0.2,
//     max_tokens: 100
//   });

//   // Parse and clean up the keywords
//   const keywordsRaw = completion.choices[0].message.content || '';
//   return keywordsRaw
//     .split(',')
//     .map(k => k.trim())
//     .filter(k => k.length > 1);
// }

// const extractTicketContext = async (issue) => {
//   const fields = issue.fields || {};
//   const iWantField = process.env.JIRA_IWANT_FIELD;
//   const soThatField = process.env.JIRA_SOTHAT_FIELD;
//   const acField = process.env.JIRA_AC_FIELD;

//   // Helper to extract plain text from ADF or string (handles empty content arrays and lists)
//   function extractADFValue(val) {
//     if (!val) return '';
//     if (typeof val === 'string') return val;
//     if (typeof val === 'object' && val.type === 'doc' && Array.isArray(val.content)) {
//       // Recursively extract all text from paragraphs, lists, etc.
//       function extractFromNodes(nodes) {
//         let result = '';
//         for (const node of nodes) {
//           if (node.type === 'paragraph' && Array.isArray(node.content)) {
//             for (const item of node.content) {
//               if (item.type === 'text') result += item.text;
//             }
//             result += '\n';
//           } else if ((node.type === 'orderedList' || node.type === 'bulletList') && Array.isArray(node.content)) {
//             for (const listItem of node.content) {
//               if (Array.isArray(listItem.content)) {
//                 result += '- ';
//                 result += extractFromNodes(listItem.content).replace(/\n$/, '') + '\n';
//               }
//             }
//           } else if (node.type === 'listItem' && Array.isArray(node.content)) {
//             result += extractFromNodes(node.content);
//           }
//         }
//         return result;
//       }
//       return extractFromNodes(val.content).trim();
//     }
//     return '';
//   }

//   let iWant = '';
//   let soThat = '';
//   let acceptanceCriteria = '';

//   if (iWantField && fields[iWantField] !== undefined) {
//     iWant = extractADFValue(fields[iWantField]);
//   } else {
//     const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('iwant'));
//     if (foundKey) {
//       iWant = extractADFValue(fields[foundKey]);
//     }
//   }

//   if (soThatField && fields[soThatField] !== undefined) {
//     soThat = extractADFValue(fields[soThatField]);
//   } else {
//     const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('sothat'));
//     if (foundKey) {
//       soThat = extractADFValue(fields[foundKey]);
//     }
//   }

//   if (acField && fields[acField] !== undefined) {
//     acceptanceCriteria = extractADFValue(fields[acField]);
//   } else {
//     const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('acceptance'));
//     if (foundKey) {
//       acceptanceCriteria = extractADFValue(fields[foundKey]);
//     }
//   }

//   // Only log the final extracted values (not all debug info)
//   console.log('--- Extracted Ticket Context ---');
//   // console.log('Summary:', fields.summary || "");
//   // // console.log('Description:', typeof fields.description === 'object'
//   //   ? extractTextFromADF(fields.description)
//   //   : (fields.description || ""));
//   // console.log('I Want:', iWant);
//   // console.log('So That:', soThat);
//   // console.log('Acceptance Criteria:', acceptanceCriteria);

//   // Extract smart keywords using OpenAI
//   const keywords = await extractFunctionalKeywordsFromTicket({
//     summary: fields.summary || "",
//     description: typeof fields.description === 'object'
//       ? extractTextFromADF(fields.description)
//       : (fields.description || ""),
//     iWant,
//     soThat,
//     acceptanceCriteria
//   });

//   console.log('Extracted Keywords:', keywords);

//   return {
//     id: issue.key,
//     summary: fields.summary || "",
//     description: typeof fields.description === 'object'
//       ? extractTextFromADF(fields.description)
//       : (fields.description || ""),
//     iWant,
//     soThat,
//     acceptanceCriteria,
//     keywords
//   };
// };

// // AGENT 3: Similar Ticket Retriever Agent (batching, uses keywords)
// const fetchSimilarTicketsBatch = async (targetTicket, batchSize = 50) => {
//   console.log("Starting to fetch similar tickets for:", targetTicket.id);
//   const keywordsArr = targetTicket.keywords || [];
//   console.log("yha h targetTicket", targetTicket);
//   if (keywordsArr.length === 0) {
//     console.warn('No suitable keywords for JQL. Skipping similar ticket search.');
//     return [];
//   }
//   // Build a JQL that matches any of the keywords in summary or description
//   /*const keywordJql = keywordsArr.map(kw =>
//     `(text ~ "${kw}")`
//   ).join(' OR ');*/

//   const keywordString = keywordsArr.join(' OR ');
//   const jql = `type = Enhancement AND status = Released AND project = RSOFT AND key != "${targetTicket.id}" AND textfields ~ "${keywordString}"`;
//   //const jql = `issuetype = "Enhancement" AND status = "Released" AND project = RSOFT AND key != "${targetTicket.id}" AND (${keywordJql})`;
// console.log(`JQL for similar tickets: ${jql}`);
 
//   let startAt = 0;
//   let allSimilar = [];
//   while (true) {
//     try {
//       const response = await axios.get(
//         `${process.env.JIRA_BASE_URL}/rest/api/3/search`,
//         {
//           params: {
//             jql,
//             fields: [
//               "summary",
//               "description",
//               process.env.JIRA_IWANT_FIELD,
//               process.env.JIRA_SOTHAT_FIELD,
//               process.env.JIRA_AC_FIELD,
//               process.env.JIRA_DOCBY_FIELD,
//               "issuetype",
//               "status"
//             ].join(","),
//             maxResults: batchSize,
//             startAt
//           },
//           auth: {
//             username: process.env.JIRA_EMAIL,
//             password: process.env.JIRA_API_TOKEN
//           },
//           headers: { Accept: 'application/json' }
//         }
//       );
//       const issues = response.data.issues || [];
//       console.log(`Fetched ${issues.length} similar tickets (batch starting at ${startAt})`);
//       allSimilar.push(...issues);
//       if (issues.length < batchSize) break;
//       startAt += batchSize;
//     } catch (error) {
//       // Log the JQL and error for debugging
//       console.error("Error fetching similar tickets batch:", error.response?.data?.errorMessages || error.message);
//       console.error("JQL used:", jql);
//       break;
//     }
//   }
//   // Filter for real similarity (at least 1 keyword in common)
//   const targetWords = new Set(keywordsArr.map(w => w.toLowerCase()));
//   const filtered = await Promise.all(
//     allSimilar.map(async issue => {
//       const t = await extractTicketContext(issue);
//       const words = new Set((t.keywords || []).map(w => w.toLowerCase()));
//       const intersection = [...words].filter(w => targetWords.has(w));
//       return intersection.length > 0 ? t : null;
//     })
//   );
//   const filteredTickets = filtered.filter(Boolean);
//   // Log filtered ticket keys
//   console.log(`Filtered to ${filteredTickets.length} truly similar tickets:`, filteredTickets.map(t => t.id).join(', '));
//   return filteredTickets;
// };

// // AGENT 4: Epic Generator Agent
// const generateEpicFromTickets = async (tickets, similarTicketsMap) => {
//   const prompt = `
// You are a Business Analyst. Based on the following Jira enhancement tickets and their similar tickets, write a comprehensive Jira Epic.

// Tickets:
// ${tickets.map(t => `
// Ticket [${t.id}]:
// Summary: ${t.summary}
// Description: ${t.description}
// I Want: ${t.iWant}
// So That: ${t.soThat}
// Acceptance Criteria: ${t.acceptanceCriteria}
// Similar Tickets: ${similarTicketsMap[t.id].map(st => st.id).join(', ')}
// -------------------`).join('\n')}

// Please structure your response in the following format:

// Summary: [Write a clear, specific, and outcome-focused summary]

// Description:
// [Provide a brief overview of the business need and value]

// I Want:
// [Outline the main features and capabilities to be delivered]
// [Describe the key requirements, organized by theme]

// Acceptance Criteria:
// [List specific, measurable criteria for success]

// So That:
// [The requirement benefits or outcomes expected from this Epic]

// Guidelines:
// - Combine and consolidate similar requirements
// - Eliminate redundancies while maintaining complete scope
// - Ensure traceability to original tickets
// - Keep the description business-oriented and implementation-neutral
// `;

//   const completion = await openai.chat.completions.create({
//     model: "gpt-4.1-nano",
//     messages: [
//       { role: "system", content: "You are a business analyst skilled at creating comprehensive epics from multiple user stories." },
//       { role: "user", content: prompt }
//     ],
//     temperature: 0.7,
//     max_tokens: 1200
//   });

//   console.log('Epic content generated by OpenAI');
//   return completion.choices[0].message.content;
// };

// // --- NEW ENDPOINT: Jira Webhook for Status Change ---
// app.post('/jira-webhook', async (req, res) => {
//   try {
//     const webhookEvent = req.body;
//     const dryRun = webhookEvent.dryRun === true;
//     const issue = webhookEvent.issue;
//     const changelog = webhookEvent.changelog;

//     if (!issue || !changelog) {
//       return res.status(200).json({ message: 'No issue/changelog in webhook, ignoring.' });
//     }

//     // Only proceed if issue is Enhancement and status changed from Open to Documentation
//     const issueType = issue.fields.issuetype?.name;
//     const statusChange = changelog.items.find(
//       item => item.field === 'status' && item.fromString === 'Open' && item.toString === 'Documentation'
//     );

//     // Check "Documentation By" field (customfield_10045 or from env)
//     const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
//     const docByValue = Array.isArray(issue.fields[docByField])
//       ? issue.fields[docByField][0]?.value
//       : (issue.fields[docByField]?.value || issue.fields[docByField]);

//     if (
//       issueType !== 'Enhancement' ||
//       !statusChange ||
//       docByValue !== 'Automation'
//     ) {
//       return res.status(200).json({ message: 'Not Enhancement, not Open→Documentation, or Documentation By not Automation. Ignoring.' });
//     }

//     const ticketKey = issue.key;
//     console.log("Received webhook for ticket:", ticketKey);
//         // Agent 1: Read the single relevant ticket
//     const rawTicket = await fetchEnhancementTicketByKey(ticketKey);
//     if (!rawTicket) {
//       return res.status(404).json({ error: "No matching enhancement ticket found." });
//     }
//     console.log(`Fetched ticket: ${rawTicket.key} - ${rawTicket.fields.summary}`);
    
//     // Agent 2: Extract context
//     const ticket = await extractTicketContext(rawTicket);
//     console.log('Extracted ticket context:', ticket);

//     // Agent 3: Find similar tickets in batches
//     const similarTickets = await fetchSimilarTicketsBatch(ticket);

//     // Agent 4: Generate Epic
//     const tickets = [ticket, ...similarTickets];
//     const similarTicketsMap = {};
//     tickets.forEach(t => {
//       similarTicketsMap[t.id] = tickets.filter(other => other.id !== t.id && (() => {
//         const tWords = new Set((t.keywords || []).map(w => w.toLowerCase()));
//         const oWords = new Set((other.keywords || []).map(w => w.toLowerCase()));
//         const intersection = [...tWords].filter(w => oWords.has(w));
//         return intersection.length > 0;
//       })());
//     });

//     const epicContent = await generateEpicFromTickets(tickets, similarTicketsMap);

//     // Always log the epic details before creation
//     const parsedContent = parseEpicContent(epicContent);
//     console.log('=== EPIC PREVIEW ===');
//     console.log('Summary:', parsedContent.summary);
//     console.log('Description:', parsedContent.description);
//     console.log('I Want:', parsedContent.iWant);
//     console.log('So That:', parsedContent.soThat);
//     console.log('Acceptance Criteria:', parsedContent.acceptanceCriteria);
//     console.log('====================');

//     // DRY RUN: Show details instead of creating epic
//     if (dryRun) {
//       return res.json({
//         dummyEpicKey: 'DUMMY-EPIC-KEY',
//         summary: parsedContent.summary,
//         description: parsedContent.description,
//         iWant: parsedContent.iWant,
//         soThat: parsedContent.soThat,
//         acceptanceCriteria: parsedContent.acceptanceCriteria,
//         fullEpicContent: epicContent
//       });
//     }

//     // Create Epic in Jira
//     const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id));
//     res.json({
//       jiraEpicKey: jiraEpic?.key,
//       jiraEpicUrl: jiraEpic ? `${process.env.JIRA_BASE_URL}/browse/${jiraEpic.key}` : null
//     });
//   } catch (error) {
//     console.error("Error in webhook epic generation:", error);
//     const errorMessage = error.response?.data?.message || error.message;
//     res.status(500).json({
//       error: "Failed to auto-generate Epic from webhook",
//       details: errorMessage
//     });
//   }
// });

// // Health check endpoint
// app.get('/health', (req, res) => {
//   res.status(200).json({ status: 'OK' });
// });

// // Error handler
// app.use((err, req, res, next) => {
//   console.error('Error:', err.message);
//   res.status(500).json({ error: 'Internal server error' });
// });

// // Start the server
// const PORT = process.env.PORT || 5000;
// app.listen(PORT, () => {
//   console.log(`Server is running on port ${PORT}`);
// });

const express = require('express');
const axios = require('axios');
const cors = require('cors');
require('dotenv').config();
const { OpenAI } = require('openai');
const { fetchGitHubFiles } = require('./gitfileembedding'); // <-- Make sure this is exported

const app = express();
app.use(cors());
app.use(express.json());

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Helper function to safely get field values
const getFieldValue = (fields, fieldId) => {
  try {
    const field = fields[fieldId];
    if (!field) return '';
    if (typeof field === 'object' && field.value) return field.value;
    if (typeof field === 'string') return field;
    return '';
  } catch (error) {
    return '';
  }
};

// Helper function to extract text from Atlassian Document Format
const extractTextFromADF = (adfContent) => {
  if (!adfContent || !adfContent.content) return '';
  return adfContent.content.reduce((text, item) => {
    if (item.type === 'paragraph' && item.content) {
      const paragraphText = item.content.reduce((paraText, contentItem) => {
        if (contentItem.type === 'text') {
          return paraText + contentItem.text;
        }
        return paraText;
      }, '');
      return text + paragraphText + '\n';
    }
    return text;
  }, '').trim();
};

// Helper function to create Atlassian Document Format
const createADF = (text) => {
  return {
    version: 1,
    type: "doc",
    content: [
      {
        type: "paragraph",
        content: [{ type: "text", text: text || '' }]
      }
    ]
  };
};

// Helper function to parse epic content into sections
const parseEpicContent = (content) => {
  const sections = {
    summary: '',
    description: '',
    iWant: '',
    soThat: '',
    acceptanceCriteria: ''
  };
  const lines = content.split('\n');
  let currentSection = '';
  for (const line of lines) {
    const trimmed = line.trim();
    if (/^(Epic Summary:|Summary:)/i.test(trimmed)) {
      currentSection = 'summary';
      const summaryValue = trimmed.replace(/^(Epic Summary:|Summary:)/i, '').trim();
      if (summaryValue) {
        sections.summary = summaryValue;
      }
    } else if (/^Description:/i.test(trimmed) || /^Business Context:/i.test(trimmed)) {
      currentSection = 'description';
    } else if (/^I Want:/i.test(trimmed)) {
      currentSection = 'iWant';
    } else if (/^So That:/i.test(trimmed)) {
      currentSection = 'soThat';
    } else if (/^Acceptance Criteria:/i.test(trimmed)) {
      currentSection = 'acceptanceCriteria';
    } else if (trimmed && currentSection) {
      if (currentSection !== 'summary') {
        sections[currentSection] += trimmed + '\n';
      } else if (!sections.summary && !/^(epic summary:|summary:)$/i.test(trimmed)) {
        sections.summary = trimmed;
      }
    }
  }
  if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
    const firstContentLine = lines.find(l =>
      l.trim() &&
      !/^epic summary:/i.test(l.trim()) &&
      !/^summary:/i.test(l.trim()) &&
      !/^description:/i.test(l.trim()) &&
      !/^business context:/i.test(l.trim()) &&
      !/^i want:/i.test(l.trim()) &&
      !/^so that:/i.test(l.trim()) &&
      !/^acceptance criteria:/i.test(l.trim())
    );
    sections.summary = firstContentLine ? firstContentLine.trim() : 'Epic generated by AI';
  }
  Object.keys(sections).forEach(key => {
    if (key !== 'summary') {
      sections[key] = sections[key].trim();
    }
  });
  sections.summary = sections.summary.replace(/^(Epic Summary:|Summary:)/i, '').trim();
  if (sections.summary.length > 255) {
    sections.summary = sections.summary.slice(0, 252) + '...';
  }
  if (!sections.summary || /^(epic summary:|summary:)$/i.test(sections.summary)) {
    sections.summary = 'Epic generated by AI';
  }
  return sections;
};

// Helper function to create Jira Epic
const createJiraEpic = async (epicContent, ticketIds) => {
  try {
    if (!process.env.JIRA_PROJECT_KEY) {
      throw new Error('JIRA_PROJECT_KEY is not configured');
    }
    await axios.get(
      `${process.env.JIRA_BASE_URL}/rest/api/3/project/${process.env.JIRA_PROJECT_KEY}`,
      {
        auth: {
          username: process.env.JIRA_EMAIL,
          password: process.env.JIRA_API_TOKEN
        }
      }
    );
    const parsedContent = parseEpicContent(epicContent);
    console.log('Parsed Epic Content:', parsedContent);
    const response = await axios.post(
      `${process.env.JIRA_BASE_URL}/rest/api/3/issue`,
      {
        fields: {
          project: { key: process.env.JIRA_PROJECT_KEY },
          summary: parsedContent.summary,
          description: createADF(parsedContent.description),
          issuetype: { name: "Epic" },
          [process.env.JIRA_IWANT_FIELD]: createADF(parsedContent.iWant),
          [process.env.JIRA_SOTHAT_FIELD]: createADF(parsedContent.soThat),
          [process.env.JIRA_AC_FIELD]: createADF(parsedContent.acceptanceCriteria)
        }
      },
      {
        auth: {
          username: process.env.JIRA_EMAIL,
          password: process.env.JIRA_API_TOKEN
        },
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      }
    );
    console.log('=== JIRA EPIC CREATION DETAILS ===');
    console.log('Epic Key:', response.data.key);
    console.log('Epic URL:', `${process.env.JIRA_BASE_URL}/browse/${response.data.key}`);
    console.log('Linked Tickets:', ticketIds);
    console.log('================================');
    return response.data;
  } catch (error) {
    console.error('Error creating Jira Epic:',
      error.response?.data?.errors ||
      error.response?.data?.errorMessages ||
      error.message
    );
    throw error;
  }
};

// AGENT 1: Ticket Reader Agent (fetches a single enhancement ticket by key)
const fetchEnhancementTicketByKey = async (ticketKey) => {
  try {
    const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
    let response;
    try {
      response = await axios.get(
        `${process.env.JIRA_BASE_URL}/rest/api/3/issue/${ticketKey}`,
        {
          auth: {
            username: process.env.JIRA_EMAIL,
            password: process.env.JIRA_API_TOKEN
          },
          headers: { Accept: 'application/json' }
        }
      );
    } catch (error) {
      console.error("Jira errorMessages:", error.response?.data?.errorMessages);
      return null;
    }
    const issue = response.data;
    if (!issue.fields.hasOwnProperty(docByField)) {
      console.error(`Field '${docByField}' is NOT present in the available fields. Check field context, screens, and permissions in Jira.`);
      return null;
    }
    if (
      issue.fields.issuetype?.name === "Enhancement" &&
      (Array.isArray(issue.fields[docByField])
        ? issue.fields[docByField][0]?.value
        : (issue.fields[docByField]?.value || issue.fields[docByField])) === "Automation"
    ) {
      return issue;
    }
    return null;
  } catch (error) {
    console.error("Error fetching enhancement ticket:", error.message);
    if (error.response?.data?.errorMessages) {
      console.error("Jira errorMessages:", error.response.data.errorMessages);
    }
    return null;
  }
};

// AGENT 2: Context Extractor Agent (async, uses OpenAI for keywords)
async function extractFunctionalKeywordsFromTicket(ticket) {
  const prompt = `
Given the following Jira enhancement ticket details, extract 3-8 keywords or short phrases that best describe the main functionality, features, or business logic of the ticket. 
Ignore generic words like "the", "this", "that", "need", "user", "system", etc. 
Focus on terms that would help find other tickets with similar functionality. 
Return the keywords as a comma-separated list.

Summary: ${ticket.summary}
Description: ${ticket.description}
I Want: ${ticket.iWant}
So That: ${ticket.soThat}
Acceptance Criteria: ${ticket.acceptanceCriteria}
`;

  const completion = await openai.chat.completions.create({
    model: "gpt-4.1-nano",
    messages: [
      { role: "system", content: "You are an expert at extracting concise, relevant keywords from Jira tickets." },
      { role: "user", content: prompt }
    ],
    temperature: 0.2,
    max_tokens: 100
  });

  const keywordsRaw = completion.choices[0].message.content || '';
  return keywordsRaw
    .split(',')
    .map(k => k.trim())
    .filter(k => k.length > 1);
}

const extractTicketContext = async (issue) => {
  const fields = issue.fields || {};
  const iWantField = process.env.JIRA_IWANT_FIELD;
  const soThatField = process.env.JIRA_SOTHAT_FIELD;
  const acField = process.env.JIRA_AC_FIELD;

  function extractADFValue(val) {
    if (!val) return '';
    if (typeof val === 'string') return val;
    if (typeof val === 'object' && val.type === 'doc' && Array.isArray(val.content)) {
      function extractFromNodes(nodes) {
        let result = '';
        for (const node of nodes) {
          if (node.type === 'paragraph' && Array.isArray(node.content)) {
            for (const item of node.content) {
              if (item.type === 'text') result += item.text;
            }
            result += '\n';
          } else if ((node.type === 'orderedList' || node.type === 'bulletList') && Array.isArray(node.content)) {
            for (const listItem of node.content) {
              if (Array.isArray(listItem.content)) {
                result += '- ';
                result += extractFromNodes(listItem.content).replace(/\n$/, '') + '\n';
              }
            }
          } else if (node.type === 'listItem' && Array.isArray(node.content)) {
            result += extractFromNodes(node.content);
          }
        }
        return result;
      }
      return extractFromNodes(val.content).trim();
    }
    return '';
  }

  let iWant = '';
  let soThat = '';
  let acceptanceCriteria = '';

  if (iWantField && fields[iWantField] !== undefined) {
    iWant = extractADFValue(fields[iWantField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('iwant'));
    if (foundKey) {
      iWant = extractADFValue(fields[foundKey]);
    }
  }

  if (soThatField && fields[soThatField] !== undefined) {
    soThat = extractADFValue(fields[soThatField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('sothat'));
    if (foundKey) {
      soThat = extractADFValue(fields[foundKey]);
    }
  }

  if (acField && fields[acField] !== undefined) {
    acceptanceCriteria = extractADFValue(fields[acField]);
  } else {
    const foundKey = Object.keys(fields).find(k => k.toLowerCase().includes('acceptance'));
    if (foundKey) {
      acceptanceCriteria = extractADFValue(fields[foundKey]);
    }
  }

  const keywords = await extractFunctionalKeywordsFromTicket({
    summary: fields.summary || "",
    description: typeof fields.description === 'object'
      ? extractTextFromADF(fields.description)
      : (fields.description || ""),
    iWant,
    soThat,
    acceptanceCriteria
  });

  console.log('Extracted Keywords:', keywords);

  return {
    id: issue.key,
    summary: fields.summary || "",
    description: typeof fields.description === 'object'
      ? extractTextFromADF(fields.description)
      : (fields.description || ""),
    iWant,
    soThat,
    acceptanceCriteria,
    keywords
  };
};

// AGENT 3: Similar Ticket Retriever Agent (batching, uses keywords)
const fetchSimilarTicketsBatch = async (targetTicket, batchSize = 50) => {
  console.log("Starting to fetch similar tickets for:", targetTicket.id);
  const keywordsArr = targetTicket.keywords || [];
  if (keywordsArr.length === 0) {
    console.warn('No suitable keywords for JQL. Skipping similar ticket search.');
    return [];
  }
  const keywordString = keywordsArr.join(' OR ');
  const jql = `type = Enhancement AND status = Released AND project = RSOFT AND key != "${targetTicket.id}" AND textfields ~ "${keywordString}"`;
  console.log(`JQL for similar tickets: ${jql}`);

  let startAt = 0;
  let allSimilar = [];
  while (true) {
    try {
      const response = await axios.get(
        `${process.env.JIRA_BASE_URL}/rest/api/3/search`,
        {
          params: {
            jql,
            fields: [
              "summary",
              "description",
              process.env.JIRA_IWANT_FIELD,
              process.env.JIRA_SOTHAT_FIELD,
              process.env.JIRA_AC_FIELD,
              process.env.JIRA_DOCBY_FIELD,
              "issuetype",
              "status"
            ].join(","),
            maxResults: batchSize,
            startAt
          },
          auth: {
            username: process.env.JIRA_EMAIL,
            password: process.env.JIRA_API_TOKEN
          },
          headers: { Accept: 'application/json' }
        }
      );
      const issues = response.data.issues || [];
      console.log(`Fetched ${issues.length} similar tickets (batch starting at ${startAt})`);
      allSimilar.push(...issues);
      if (issues.length < batchSize) break;
      startAt += batchSize;
    } catch (error) {
      console.error("Error fetching similar tickets batch:", error.response?.data?.errorMessages || error.message);
      console.error("JQL used:", jql);
      break;
    }
  }
  const targetWords = new Set(keywordsArr.map(w => w.toLowerCase()));
  const filtered = await Promise.all(
    allSimilar.map(async issue => {
      const t = await extractTicketContext(issue);
      const words = new Set((t.keywords || []).map(w => w.toLowerCase()));
      const intersection = [...words].filter(w => targetWords.has(w));
      return intersection.length > 0 ? t : null;
    })
  );
  const filteredTickets = filtered.filter(Boolean);
  console.log(`Filtered to ${filteredTickets.length} truly similar tickets:`, filteredTickets.map(t => t.id).join(', '));
  return filteredTickets;
};

// AGENT 4: Ticket Code Context Retriever (panelName + formPath)
const PANELNAME_TO_REPO = {
  "LCO Panel": "OnnetWeb-OnNetSinglePlay",
  "Admin Panel": "OnnetWeb-AdminPanelConsole",
  "MyCableTv Web": "MycableTVWithPayTV",
  "MyCableTv AndroidApp": "MycableTVWithPayTV",
  "MyCableTv iOS App": "MycableTVWithPayTV",
  "PayTvSelfCare Web": "MycableTVWithPayTV",
  "PayTvSelfCare Android Native": "MycableTVWithPayTV",
  "PayTvSelfCare iOS Native": "MycableTVWithPayTV",
  "Collection App": "Collection-Application-New",
  "LCO Android App": "LcoAppNew",
  "MyCableTv React": "MYCABLETVREACT"
};

async function fetchTicketCodeContext(panelName, formPath, branch = 'develop') {
  const repoName = PANELNAME_TO_REPO[panelName];
  if (!repoName) {
    throw new Error(`Unknown panel name: ${panelName}`);
  }
  const fileNames = Array.isArray(formPath) ? formPath : [formPath];
  const { plainEnglishDescription } = await fetchGitHubFiles(fileNames, repoName, branch);
  return {
    repoName,
    fileNames,
    plainEnglishDescription
  };
}

// AGENT 5: Epic Creator Agent (combines all agents)
const createEpicWithAllContext = async ({
  ticketKey,
  panelName,
  formPath,
  dryRun = true
}) => {
  const rawTicket = await fetchEnhancementTicketByKey(ticketKey);
  if (!rawTicket) throw new Error("No matching enhancement ticket found.");

  const ticket = await extractTicketContext(rawTicket);
  const similarTickets = await fetchSimilarTicketsBatch(ticket);
  const codeContext = await fetchTicketCodeContext(panelName, formPath);

  const tickets = [ticket, ...similarTickets];
  const similarTicketsMap = {};
  tickets.forEach(t => {
    similarTicketsMap[t.id] = tickets.filter(other => other.id !== t.id && (() => {
      const tWords = new Set((t.keywords || []).map(w => w.toLowerCase()));
      const oWords = new Set((other.keywords || []).map(w => w.toLowerCase()));
      const intersection = [...tWords].filter(w => oWords.has(w));
      return intersection.length > 0;
    })());
  });

  const epicContent = await generateEpicFromTickets(tickets, similarTicketsMap, codeContext);

  const parsedContent = parseEpicContent(epicContent);

  if (dryRun) {
    return {
      dummyEpicKey: 'DUMMY-EPIC-KEY',
      summary: parsedContent.summary,
      description: parsedContent.description,
      iWant: parsedContent.iWant,
      soThat: parsedContent.soThat,
      acceptanceCriteria: parsedContent.acceptanceCriteria,
      codeContext,
      fullEpicContent: epicContent
    };
  }

  const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id));
  return {
    jiraEpicKey: jiraEpic?.key,
    jiraEpicUrl: jiraEpic ? `${process.env.JIRA_BASE_URL}/browse/${jiraEpic.key}` : null
  };
};

// AGENT 4/5-aware Epic Generator
const generateEpicFromTickets = async (tickets, similarTicketsMap, codeContext = null) => {
  const codeSection = codeContext
    ? `\n\nCode Context (from panel "${codeContext.repoName}", files: ${codeContext.fileNames.join(', ')}):\n${codeContext.plainEnglishDescription}\n`
    : '';
  const prompt = `
You are a Business Analyst. Based on the following Jira enhancement tickets and their similar tickets, write a comprehensive Jira Epic.

Tickets:
${tickets.map(t => `
Ticket [${t.id}]:
Summary: ${t.summary}
Description: ${t.description}
I Want: ${t.iWant}
So That: ${t.soThat}
Acceptance Criteria: ${t.acceptanceCriteria}
Similar Tickets: ${similarTicketsMap[t.id].map(st => st.id).join(', ')}
-------------------`).join('\n')}
${codeSection}
Please structure your response in the following format:

Summary: [Write a clear, specific, and outcome-focused summary]

Description:
[Provide a brief overview of the business need and value]

I Want:
[Outline the main features and capabilities to be delivered]
[Describe the key requirements, organized by theme]

Acceptance Criteria:
[List specific, measurable criteria for success]

So That:
[The requirement benefits or outcomes expected from this Epic]

Guidelines:
- Combine and consolidate similar requirements
- Eliminate redundancies while maintaining complete scope
- Ensure traceability to original tickets
- Keep the description business-oriented and implementation-neutral
`;

  const completion = await openai.chat.completions.create({
    model: "gpt-4.1-nano",
    messages: [
      { role: "system", content: "You are a business analyst skilled at creating comprehensive epics from multiple user stories." },
      { role: "user", content: prompt }
    ],
    temperature: 0.7,
    max_tokens: 1200
  });

  console.log('Epic content generated by OpenAI');
  return completion.choices[0].message.content;
};

// --- NEW ENDPOINT: Full Epic Generation with Code Context ---
app.post('/generate-epic-with-code-context', async (req, res) => {
  try {
    const { ticketKey, panelName, formPath, dryRun } = req.body;
    const result = await createEpicWithAllContext({ ticketKey, panelName, formPath, dryRun });
    res.json(result);
  } catch (error) {
    console.error("Error in full epic generation:", error);
    res.status(500).json({
      error: "Failed to auto-generate Epic with code context",
      details: error.message
    });
  }
});

// --- EXISTING ENDPOINT: Jira Webhook for Status Change ---
app.post('/jira-webhook', async (req, res) => {
  try {
    const webhookEvent = req.body;
    const dryRun = webhookEvent.dryRun === true;
    const issue = webhookEvent.issue;
    const changelog = webhookEvent.changelog;

    if (!issue || !changelog) {
      return res.status(200).json({ message: 'No issue/changelog in webhook, ignoring.' });
    }

    const issueType = issue.fields.issuetype?.name;
    const statusChange = changelog.items.find(
      item => item.field === 'status' && item.fromString === 'Open' && item.toString === 'Documentation'
    );

    const docByField = process.env.JIRA_DOCBY_FIELD || 'customfield_10045';
    const docByValue = Array.isArray(issue.fields[docByField])
      ? issue.fields[docByField][0]?.value
      : (issue.fields[docByField]?.value || issue.fields[docByField]);

    if (
      issueType !== 'Enhancement' ||
      !statusChange ||
      docByValue !== 'Automation'
    ) {
      return res.status(200).json({ message: 'Not Enhancement, not Open→Documentation, or Documentation By not Automation. Ignoring.' });
    }

    const ticketKey = issue.key;
    console.log("Received webhook for ticket:", ticketKey);
    const rawTicket = await fetchEnhancementTicketByKey(ticketKey);
    if (!rawTicket) {
      return res.status(404).json({ error: "No matching enhancement ticket found." });
    }
    console.log(`Fetched ticket: ${rawTicket.key} - ${rawTicket.fields.summary}`);
    const ticket = await extractTicketContext(rawTicket);
    console.log('Extracted ticket context:', ticket);

    const similarTickets = await fetchSimilarTicketsBatch(ticket);

    const tickets = [ticket, ...similarTickets];
    const similarTicketsMap = {};
    tickets.forEach(t => {
      similarTicketsMap[t.id] = tickets.filter(other => other.id !== t.id && (() => {
        const tWords = new Set((t.keywords || []).map(w => w.toLowerCase()));
        const oWords = new Set((other.keywords || []).map(w => w.toLowerCase()));
        const intersection = [...tWords].filter(w => oWords.has(w));
        return intersection.length > 0;
      })());
    });

    const epicContent = await generateEpicFromTickets(tickets, similarTicketsMap);

    const parsedContent = parseEpicContent(epicContent);
    console.log('=== EPIC PREVIEW ===');
    console.log('Summary:', parsedContent.summary);
    console.log('Description:', parsedContent.description);
    console.log('I Want:', parsedContent.iWant);
    console.log('So That:', parsedContent.soThat);
    console.log('Acceptance Criteria:', parsedContent.acceptanceCriteria);
    console.log('====================');

    if (dryRun) {
      return res.json({
        dummyEpicKey: 'DUMMY-EPIC-KEY',
        summary: parsedContent.summary,
        description: parsedContent.description,
        iWant: parsedContent.iWant,
        soThat: parsedContent.soThat,
        acceptanceCriteria: parsedContent.acceptanceCriteria,
        fullEpicContent: epicContent
      });
    }

    const jiraEpic = await createJiraEpic(epicContent, tickets.map(t => t.id));
    res.json({
      jiraEpicKey: jiraEpic?.key,
      jiraEpicUrl: jiraEpic ? `${process.env.JIRA_BASE_URL}/browse/${jiraEpic.key}` : null
    });
  } catch (error) {
    console.error("Error in webhook epic generation:", error);
    const errorMessage = error.response?.data?.message || error.message;
    res.status(500).json({
      error: "Failed to auto-generate Epic from webhook",
      details: errorMessage
    });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'OK' });
});

// Error handler
app.use((err, req, res, next) => {
  console.error('Error:', err.message);
  res.status(500).json({ error: 'Internal server error' });
});

// Start the server
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});